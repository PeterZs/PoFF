#include "PlaneObstacle.hpp"

PlaneObstacle::PlaneObstacle(float p, Vector3f n, Shader *shader) : Obstacle(shader) {
  pos = p;
  normal = n;
  normal.normalize();
}

void PlaneObstacle::animate() {

}

void PlaneObstacle::draw(glm::mat4 m, Shader *s) {
  GLfloat vertices[18] = {-0.1, -0.1, pos,   -0.1, 1, pos,    1, 1, pos,
			  1, 1, pos,  -0.1, -0.1, pos,   1, -0.1, pos};
  GLfloat normals[18] = {0, 0, 1,  0, 0, 1,  0, 0, 1,
			 0, 0, 1,  0, 0, 1,  0, 0, 1};
  GLfloat colors[18] = {0.9, 0.9, 1.0,   0.9, 0.9, 1.0,  0.9, 0.9, 1.0,
			0.9, 0.9, 1.0,   0.9, 0.9, 1.0,  0.9, 0.9, 1.0};
  enableShader();
   setMVP(m, s);
  
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, vertices);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, colors);
    glEnableVertexAttribArray(1);
    
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, vertices);
    glEnableVertexAttribArray(2);

    glDrawArrays(GL_TRIANGLES, 0, 6);

    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(0);

    disableShader();
}

float PlaneObstacle::getPosition() const {
  return pos;
}

Vector3f PlaneObstacle::getNormal(Vector3f v) const {
  return normal;
}

Vector3f PlaneObstacle::getNormal() const {
  return normal;
}

float PlaneObstacle::distance(Vector3f v) const {
  // float nv = v.norm();
  // Vector3f dir = v/nv;
  // float costheta = dir.dot(normal);
  // float dist= 0;
  // if (nv != 0 && costheta != 0) {
  //   dist = nv - pos/costheta;
  // }
  return v(2) - pos;
}

void PlaneObstacle::getCollisionValues(Vector3f p, float & dist, Vector3f &n) const {
  dist = p(2) - pos;
  n = normal;
}
